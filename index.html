<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arix Signature Interactive Christmas Tree</title>
    <meta name="description" content="A high-fidelity, cinematic 3D interactive experience featuring a morphing bohemian-luxury Christmas tree.">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body, html { margin: 0; padding: 0; height: 100%; background-color: #1a1512; overflow: hidden; }
      #root { width: 100%; height: 100%; }
      ::-webkit-scrollbar { display: none; }
    </style>
    <!-- Babel for runtime JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import Map for dependencies -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber,postprocessing",
        "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
        "maath": "https://esm.sh/maath@0.10.7?external=three",
        "uuid": "https://esm.sh/uuid@9.0.1"
      }
    }
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { Environment, OrbitControls, Float } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
        import { easing } from 'maath';

        // --- TYPES ---
        const TreeState = {
          SCATTERED: 'SCATTERED',
          TREE_SHAPE: 'TREE_SHAPE'
        };

        // --- CONSTANTS ---
        const PALETTE = {
          terracotta: '#E07A5F',
          mustard: '#E8C547',
          beige: '#F2CC8F',
          brown: '#815B5B',
          darkBrown: '#3D405B',
          gold: '#D4AF37',
          warmWhite: '#F4F1DE',
          background: '#1a1512'
        };

        const FOLIAGE_COLORS = [
          PALETTE.terracotta,
          PALETTE.brown,
          PALETTE.mustard,
          PALETTE.gold,
        ];

        const ORNAMENT_COLORS = [
          PALETTE.beige,
          PALETTE.warmWhite,
          PALETTE.gold,
          PALETTE.terracotta,
          PALETTE.mustard
        ];

        const SCENE_CONFIG = {
          treeHeight: 12,
          treeRadius: 4.5,
          scatterRadius: 25,
          foliageCount: 12000,
          ornamentCount: 300,
        };

        // Math Helpers
        const randomPointInSphere = (radius) => {
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = Math.cbrt(Math.random()) * radius;
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);
          return new THREE.Vector3(x, y, z);
        };

        const randomPointInCone = (height, radius) => {
          const h = Math.random() * height;
          const relativeH = h / height;
          const currentRadius = radius * (1 - relativeH);
          
          const theta = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * currentRadius;
          
          const x = r * Math.cos(theta);
          const z = r * Math.sin(theta);
          const y = h - (height / 2);
          
          return new THREE.Vector3(x, y, z);
        };

        // --- FOLIAGE COMPONENT ---
        const vertexShaderFoliage = `
          uniform float uTime;
          uniform float uProgress;
          uniform float uPixelRatio;

          attribute vec3 aPositionTree;
          attribute vec3 aPositionScatter;
          attribute float aSize;
          attribute vec3 aColor;

          varying vec3 vColor;
          varying float vAlpha;

          void main() {
            vColor = aColor;
            float t = uProgress;
            float ease = t * t * (3.0 - 2.0 * t);
            vec3 currentPos = mix(aPositionScatter, aPositionTree, ease);

            float noiseFreq = 2.0;
            float noiseAmp = 0.15;
            float offset = sin(uTime * noiseFreq + currentPos.x + currentPos.y) * noiseAmp;
            float scatterJitter = (1.0 - ease) * sin(uTime + currentPos.z) * 0.5;
            vec3 finalPos = currentPos + vec3(offset + scatterJitter, offset, offset);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = aSize * uPixelRatio * (50.0 / -mvPosition.z);
            vAlpha = 1.0;
          }
        `;

        const fragmentShaderFoliage = `
          varying vec3 vColor;
          varying float vAlpha;

          void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float r = length(coord);
            if (r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.5);
            gl_FragColor = vec4(vColor * 1.5, vAlpha * glow);
            if (r > 0.4) {
              gl_FragColor.rgb += vec3(0.2, 0.15, 0.0);
            }
          }
        `;

        const Foliage = ({ treeState }) => {
          const materialRef = useRef(null);
          const count = SCENE_CONFIG.foliageCount;

          const geometry = useMemo(() => {
            const geo = new THREE.BufferGeometry();
            const positionsTree = new Float32Array(count * 3);
            const positionsScatter = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
              // Tree
              const treePos = randomPointInCone(SCENE_CONFIG.treeHeight, SCENE_CONFIG.treeRadius);
              positionsTree[i * 3] = treePos.x;
              positionsTree[i * 3 + 1] = treePos.y;
              positionsTree[i * 3 + 2] = treePos.z;

              // Scatter
              const scatterPos = randomPointInSphere(SCENE_CONFIG.scatterRadius);
              positionsScatter[i * 3] = scatterPos.x;
              positionsScatter[i * 3 + 1] = scatterPos.y;
              positionsScatter[i * 3 + 2] = scatterPos.z;

              // Color
              const colorHex = FOLIAGE_COLORS[Math.floor(Math.random() * FOLIAGE_COLORS.length)];
              tempColor.set(colorHex);
              tempColor.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
              colors[i * 3] = tempColor.r;
              colors[i * 3 + 1] = tempColor.g;
              colors[i * 3 + 2] = tempColor.b;

              sizes[i] = Math.random() * 2.5 + 0.5;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positionsTree, 3));
            geo.setAttribute('aPositionTree', new THREE.BufferAttribute(positionsTree, 3));
            geo.setAttribute('aPositionScatter', new THREE.BufferAttribute(positionsScatter, 3));
            geo.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            return geo;
          }, [count]);

          useFrame((state, delta) => {
            if (materialRef.current) {
              materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
              materialRef.current.uniforms.uPixelRatio.value = state.viewport.dpr;
              const targetProgress = treeState === TreeState.TREE_SHAPE ? 1 : 0;
              easing.damp(materialRef.current.uniforms.uProgress, 'value', targetProgress, 0.8, delta);
            }
          });

          return (
            <points geometry={geometry}>
              <shaderMaterial
                ref={materialRef}
                vertexShader={vertexShaderFoliage}
                fragmentShader={fragmentShaderFoliage}
                uniforms={{
                  uTime: { value: 0 },
                  uProgress: { value: 0 },
                  uPixelRatio: { value: 1 },
                }}
                transparent
                depthWrite={false}
                blending={THREE.AdditiveBlending}
              />
            </points>
          );
        };

        // --- ORNAMENTS COMPONENT ---
        const ornamentMaterial = new THREE.ShaderMaterial({
          vertexShader: `
            uniform float uTime;
            uniform float uProgress;

            attribute vec3 aPosTree;
            attribute vec3 aPosScatter;
            attribute vec3 aColor;
            attribute float aScale;
            attribute vec3 aRotationAxis;
            attribute float aRotationSpeed;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            mat4 rotationMatrix(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                            0.0,                                0.0,                                0.0,                                1.0);
            }

            void main() {
              vColor = aColor;
              float t = uProgress;
              float ease = t * t * (3.0 - 2.0 * t);
              vec3 finalPos = mix(aPosScatter, aPosTree, ease);
              float angle = uTime * aRotationSpeed;
              mat4 rotMat = rotationMatrix(aRotationAxis, angle);
              float scale = aScale;
              vec3 transformed = position * scale;
              transformed = (rotMat * vec4(transformed, 1.0)).xyz;
              vNormal = normalize((rotMat * vec4(normal, 0.0)).xyz);
              vec4 mvPosition = modelViewMatrix * vec4(finalPos + transformed, 1.0);
              vViewPosition = -mvPosition.xyz;
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
              vec3 fdx = dFdx(vViewPosition);
              vec3 fdy = dFdy(vViewPosition);
              vec3 faceNormal = normalize(cross(fdx, fdy));
              vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
              vec3 viewDir = normalize(vViewPosition);
              float diff = max(dot(faceNormal, lightDir), 0.0);
              vec3 reflectDir = reflect(-lightDir, faceNormal);
              float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
              vec3 ambient = vec3(0.3) * vColor;
              vec3 lighting = ambient + (diff * vColor) + (spec * vec3(0.5));
              float rim = 1.0 - max(dot(viewDir, faceNormal), 0.0);
              rim = pow(rim, 3.0);
              lighting += rim * vec3(0.5, 0.4, 0.2);
              gl_FragColor = vec4(lighting, 1.0);
            }
          `,
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
          },
          side: THREE.FrontSide,
        });

        const Ornaments = ({ treeState, geometryType, count, scaleFactor }) => {
          const meshRef = useRef(null);
          const materialRef = useRef(ornamentMaterial.clone());

          const baseGeometry = useMemo(() => {
            if (geometryType === 'octahedron') return new THREE.OctahedronGeometry(1, 0);
            return new THREE.DodecahedronGeometry(0.8, 0);
          }, [geometryType]);

          const { attributes, instanceCount } = useMemo(() => {
            const posTree = new Float32Array(count * 3);
            const posScatter = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const scales = new Float32Array(count);
            const axes = new Float32Array(count * 3);
            const speeds = new Float32Array(count);
            const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
              const pt = randomPointInCone(SCENE_CONFIG.treeHeight, SCENE_CONFIG.treeRadius);
              posTree[i*3] = pt.x; posTree[i*3+1] = pt.y; posTree[i*3+2] = pt.z;
              const ps = randomPointInSphere(SCENE_CONFIG.scatterRadius);
              posScatter[i*3] = ps.x; posScatter[i*3+1] = ps.y; posScatter[i*3+2] = ps.z;
              const c = ORNAMENT_COLORS[Math.floor(Math.random() * ORNAMENT_COLORS.length)];
              tempColor.set(c);
              colors[i*3] = tempColor.r; colors[i*3+1] = tempColor.g; colors[i*3+2] = tempColor.b;
              scales[i] = (Math.random() * 0.5 + 0.3) * scaleFactor;
              const axis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
              axes[i*3] = axis.x; axes[i*3+1] = axis.y; axes[i*3+2] = axis.z;
              speeds[i] = (Math.random() - 0.5) * 1.5;
            }

            return {
              instanceCount: count,
              attributes: {
                aPosTree: new THREE.InstancedBufferAttribute(posTree, 3),
                aPosScatter: new THREE.InstancedBufferAttribute(posScatter, 3),
                aColor: new THREE.InstancedBufferAttribute(colors, 3),
                aScale: new THREE.InstancedBufferAttribute(scales, 1),
                aRotationAxis: new THREE.InstancedBufferAttribute(axes, 3),
                aRotationSpeed: new THREE.InstancedBufferAttribute(speeds, 1),
              }
            };
          }, [count, scaleFactor]);

          useFrame((state, delta) => {
            if (materialRef.current) {
              materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
              const target = treeState === TreeState.TREE_SHAPE ? 1 : 0;
              easing.damp(materialRef.current.uniforms.uProgress, 'value', target, 1.2, delta);
            }
          });

          return (
            <instancedMesh
              ref={meshRef}
              args={[baseGeometry, undefined, instanceCount]}
              frustumCulled={false}
            >
              <primitive object={attributes.aPosTree} attach="geometry-attributes-aPosTree" />
              <primitive object={attributes.aPosScatter} attach="geometry-attributes-aPosScatter" />
              <primitive object={attributes.aColor} attach="geometry-attributes-aColor" />
              <primitive object={attributes.aScale} attach="geometry-attributes-aScale" />
              <primitive object={attributes.aRotationAxis} attach="geometry-attributes-aRotationAxis" />
              <primitive object={attributes.aRotationSpeed} attach="geometry-attributes-aRotationSpeed" />
              <primitive object={materialRef.current} attach="material" />
            </instancedMesh>
          );
        };

        // --- SCENE COMPONENT ---
        const Scene = ({ treeState }) => {
          const groupRef = useRef(null);
          
          useFrame((state, delta) => {
            if (groupRef.current) {
              if (treeState === TreeState.TREE_SHAPE) {
                groupRef.current.rotation.y += delta * 0.1;
              }
            }
          });

          return (
            <React.Fragment>
              <OrbitControls 
                enablePan={false} 
                enableZoom={true} 
                minDistance={8} 
                maxDistance={40}
                autoRotate={treeState === TreeState.SCATTERED} 
                autoRotateSpeed={0.5}
              />
              
              <ambientLight intensity={0.2} color="#F2CC8F" />
              <pointLight position={[10, 10, 10]} intensity={1.5} color="#E8C547" />
              <pointLight position={[-10, -5, -10]} intensity={0.5} color="#E07A5F" />

              <Float 
                speed={1} 
                rotationIntensity={0.2} 
                floatIntensity={0.5} 
                floatingRange={[-0.5, 0.5]}
              >
                <group ref={groupRef}>
                  <Foliage treeState={treeState} />
                  <Ornaments 
                    treeState={treeState} 
                    geometryType="octahedron" 
                    count={SCENE_CONFIG.ornamentCount} 
                    scaleFactor={1.0} 
                  />
                  <Ornaments 
                    treeState={treeState} 
                    geometryType="dodecahedron" 
                    count={Math.floor(SCENE_CONFIG.ornamentCount / 3)} 
                    scaleFactor={1.5} 
                  />
                </group>
              </Float>
              <Environment preset="sunset" blur={0.8} background={false} />
            </React.Fragment>
          );
        };

        // --- APP COMPONENT ---
        const App = () => {
          const [treeState, setTreeState] = useState(TreeState.TREE_SHAPE);

          const toggleState = useCallback(() => {
            setTreeState((prev) => 
              prev === TreeState.TREE_SHAPE ? TreeState.SCATTERED : TreeState.TREE_SHAPE
            );
          }, []);

          return (
            <div className="w-full h-full relative cursor-pointer" onClick={toggleState}>
              <Canvas
                dpr={[1, 2]}
                camera={{ position: [0, 0, 20], fov: 45 }}
                gl={{ 
                  antialias: false, 
                  toneMappingExposure: 1.2, 
                  stencil: false, 
                  depth: true 
                }}
              >
                <color attach="background" args={[PALETTE.background]} />
                <Scene treeState={treeState} />
                <EffectComposer disableNormalPass>
                  <Bloom 
                    luminanceThreshold={0.8} 
                    mipmapBlur 
                    intensity={1.2} 
                    radius={0.6}
                  />
                  <Noise opacity={0.05} />
                  <Vignette eskil={false} offset={0.1} darkness={1.1} />
                </EffectComposer>
              </Canvas>

              <div className="absolute bottom-10 left-0 w-full flex justify-center pointer-events-none">
                <div className="flex flex-col items-center gap-2 opacity-50 transition-opacity duration-500 hover:opacity-100">
                  <div className="w-12 h-12 border border-[#E07A5F] rounded-full flex items-center justify-center animate-pulse">
                    <div className="w-2 h-2 bg-[#F2CC8F] rounded-full" />
                  </div>
                  <span className="text-[#F2CC8F] text-xs tracking-[0.3em] font-light uppercase opacity-70">
                    {treeState === TreeState.TREE_SHAPE ? 'Scatter' : 'Gather'}
                  </span>
                </div>
              </div>
            </div>
          );
        };

        // --- MOUNT ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>